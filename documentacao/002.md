# Making offüë®üèΩ‚Äçüíª
Programando os servidores e fazendo m√°gica.
## Experi√™ncias e diferen√ßasüí≠
### BunüßÑ
Come√ßando com esta belezura aqui:

![Captura de tela 2025-03-20 125411](https://github.com/user-attachments/assets/2a0027e8-d890-4a13-b291-935d2bf44457)

O bun tem uma vari√°vel global 'Bun' que consegue acessar a propriedade serve sem nenhuma necessidade de import√°-la, ent√£o esta primeira linha de import √© totalmente desnecess√°ria, assim como atribuir Bun.serve
a alguma constante, j√° que eu consigo passar os par√¢metros do servidor diretamente nele. Por√©m, em alguns bocados de vezes, a est√©tica e o glamour falam mais alto que a l√≥gica, ent√£o deixaremos desta forma.

Seguindo nossa constru√ß√£o, usamos ent√£o a constante app e passamos para ela um objeto, neste objetos, passamos tr√™s propriedades:
* port: A porta na qual nosso servidor estar√° exposto para comunica√ß√£o localmente, escolherei a 3000, por comodidade.
* routes: Um objeto com as rotas que queremos criar em nosso servidor.
* error: uma fun√ß√£o de tratamento de erros que retorna uma mensagem de erro caso alguma exce√ß√£o aconte√ßa.

![Captura de tela 2025-03-20 130714](https://github.com/user-attachments/assets/32e1dbc9-7c87-4be0-97d6-8d9ac614f07d)

As rotas s√£o muito simples de serem definidas, tudo o que eu precisei fazer foi escrev√™-las entre aspas e atribuir para elas um objeto chamado Response, no qual podemos passar como json ou http simples.

![image](https://github.com/user-attachments/assets/f2198841-1960-47f8-9e4c-83d514535aae)

Tamb√©m podemos atribuir imagens a esses objetos Response. Atrav√©s da fun√ß√£o file do bun, que, mais uma vez, n√£o precisa ser importada j√° que podemos acess√°-la diretamente atrav√©s do 'Bun', precisamos passar o caminho
do arquivo no qual queremos que seja lido. Por√©m, no caso de arquivos bin√°rios, precisamos usar tamb√©m outro m√©todo do bun chamado bytes, que retorna um array de bytes, necess√°rio para que o bun carregue a imagem.
Tamb√©m posso atribuir headers √†s rotas. √Äs vezes √© essencial que especifiquemos o tipo do conte√∫do da rota para que o navegador entenda o que deve mostrar.

![image](https://github.com/user-attachments/assets/85891631-4467-490f-9c83-a29e08b2cd82)
![image](https://github.com/user-attachments/assets/039ad6a8-34d6-407e-bc88-319c4946a5ad)

No bun, tamb√©m somos capazes de passar m√©todos http para nossas rotas:

![Captura de tela 2025-03-15 000210](https://github.com/user-attachments/assets/1e1dec05-40d5-40e9-83d8-ca74765cd602)

Mas, como a vida √©, quase sempre, uma m√£e desnaturada, este n√£o foi o resultado final. Durante a constru√ß√£o do servidor node, eu n√£o consegui passar json nos corpos da requisi√ß√£o, ent√£o, para que ficassem o mais parecidos poss√≠vel, o desfecho foi esse:

![image](https://github.com/user-attachments/assets/03871bce-bb4b-4003-a1b6-1d37406b5f27)
* OBS: mudei o tema do meu vscode, ent√£o existe uma diferen√ßa visual nas screenshots.

O pr√≥ximo passo foi adicionar um arquivo html como resposta de uma rota. Esta rota foi a √∫nica dificuldade que eu tive enquanto programando o servidor com bun. A leitura deste arquivo √© feita da mesma forma que a de uma imagem, a diferen√ßa est√° apenas no m√©todo que usamos, ao inv√©s de bytes, usamos o m√©todo text, que converte o arquivo lido em texto(ou string). Por√©m, o servidor n√£o conseguia ler a rota  de forma alguma. Tentei v√°rias coisas, como mudar o tipo do conte√∫do no header, usar o m√©todo bytes, procurar por algum m√©todo espec√≠fico para html e nada estava funcionando, at√© que dei o bra√ßo a torcer e pedi ajuda a algum LLM da vida.
Fui recomendado a atribuir esse arquivo a alguma vari√°vel no topo do c√≥digo, assim o arquivo seria procurado antes mesmo do servidor ser iniciado, j√° que, por algum motivo, await n√£o tinha nenhum efeito sobre este arquivo, o que n√£o fez muito sentido para mim. Mas, de uma forma ou de outra, fez sentido, j√° que o arquivo carregou ap√≥s isso. Provavelmente - leia-se 'com certeza' - eu estava errado quanto a forma na qual o servidor bun trabalha.

![Captura de tela 2025-03-15 011211](https://github.com/user-attachments/assets/2a9b060c-ef12-46e7-bbfc-038c07e3dc77)
* OBS: N√£o tem m√©todo usado junto √† fun√ß√£o na screenshot, mas nenhum funcionava.

![image](https://github.com/user-attachments/assets/a9bf9c3b-e810-4833-be61-bf25f9ca6098)
![image](https://github.com/user-attachments/assets/b8960922-d829-48b4-b116-a8e550b886f5)
![image](https://github.com/user-attachments/assets/2e45536a-ec55-43f2-bde0-bad317be35d6)

As outras rotas foram mais do mesmo.

![image](https://github.com/user-attachments/assets/bea17b89-f3ac-42a9-b20d-49e4a6b8109d)

E, por √∫ltimo, a fun√ß√£o erro.

![image](https://github.com/user-attachments/assets/2f04f8aa-b765-4450-a97b-dd989c9b05c0)

Construir um servidor bun foi, de fato, uma experi√™ncia √≥tima. √â uma ferramenta bastante f√°cil de se utilizar e tem uma documenta√ß√£o bastante robusta e completa e que ajudou bastante na constru√ß√£o deste servidor. Desenvolver com bun realmente tornou o trabalho muito mais r√°pido e eficiente, reduzindo a necessidade de diversas coisas pelo fato do bun te oferecer uma gama de outras ferramentas para desenvolvimento de forma nativa, reduzindo n√£o s√≥ a complexidade de construir um servidor como tamb√©m reduzindo o tamanho do c√≥digo.

![image](https://github.com/user-attachments/assets/9155601d-8ead-421b-be05-3f372f2f1155)
* 50 linhas de c√≥digo

### Nodeü™¢

Bom, pelo fato do node ser usado no CITi e em outros projetos no qual eu estou inserido, eu tenho bem mais familiaridade com ele. N√£o em sua forma pura, √© claro, mas √© contato, de qualquer forma. Por√©m, isso n√£o me impediu de ter problemas durante o desenvolvimento tamb√©m.

Comecei importando os m√≥dulos que eu precisaria usar no servidor, essas linhas eu posso dizer que foram necess√°rias. Ap√≥s isso, atribu√≠ a fun√ß√£o create server a uma constante chamada server, para que ela passasse a ter as propriedades de tal. Dentro da pr√≥pria atribui√ß√£o passei a fun√ß√£o que ser√° nosso servidor e fui construindo.

![image](https://github.com/user-attachments/assets/09efa8c1-de44-40ac-aacd-95ac1ac53e36)

Desestruturei 'method' e 'url' do objeto req, que representa a requisi√ß√£o para o nosso servidor. method e url s√£o, respectivamente, o m√©todo http requisitado e a rota a ser acessada em nosso servidor.

![image](https://github.com/user-attachments/assets/1943c68b-26ea-4ae2-9fcd-6617e51e539b)

Ap√≥s isso, envolvi todo o servidor em um try catch para tratamentos de erro.

Para definir as rotas, usei estruturas condicionais (if/else) para analisar a url e o m√©todo pedido e direcionar o servidor para a rota desejada.

![image](https://github.com/user-attachments/assets/f24de31a-04f5-4b04-a7f8-3f0e8769a5f5)

Se compararmos com a forma na qual isso foi feito no servidor bun, podemos perceber que, de fato, isto √© um pouco mais complexo e chato de se fazer.

Quanto √† leitura de arquivos, n√£o existe muita diferen√ßa entre o bun e o node. No node temos o m√≥dulo 'fs', que faz a mesma coisa que o Bun.file, com a diferen√ßa de que no node n√£o precisamos de mais nenhum outro m√©todo para 'traduzir' os arquivos. Ponto pro node!
Al√©m disso, passamos a resposta dos servidores diretamente como uma fun√ß√£o de callback na fun√ß√£o readFile, com direito a tratamento de erro.

![image](https://github.com/user-attachments/assets/8dc17a09-c377-443f-8ea4-d219ca99a84b)
![image](https://github.com/user-attachments/assets/9beb11ed-9d6a-4ed8-9dac-a797ae3f5a0e)

Para ministrar os m√©todos http pedidos, eu fiz v√°rios ifs aninhados em um √∫nico if. A condicional principal verifica a url do requisi√ß√£o enquanto os ifs filhos verificam os m√©todos, funciona muito bem, apesar de ser extenso e chato de se fazer.

![image](https://github.com/user-attachments/assets/b4e87d21-440e-4502-ab61-96c1d3f461e5)

Aqui eu tive um problema, como mencionado anteriormente, eu tinha em mente usar json para pegar dados inseridos por mim(ou por voc√™, que por algum motivo est√° testando isso) no corpo da requisi√ß√£o, mas n√£o deu muito certo e substitu√≠ por requisi√ß√µes e respostas simples.

![Captura de tela 2025-03-15 000136](https://github.com/user-attachments/assets/5e16e13e-9b15-4a87-a309-be5d2881ba4f)
* Pode parecer meio rid√≠culo o que eu estava tentando fazer aqui mas era s√≥ eu testando tudo o que eu vinha na cabe√ßa.

Quanto a servir arquivos html, o processo √© o mesmo do de imagens e n√£o tive nenhum tipo de problema com isso, diferente do bun.

![image](https://github.com/user-attachments/assets/34c1933e-04a8-4c92-bca5-0c969599575d)

As outras rotas foram s√≥ mais do mesmo.

![image](https://github.com/user-attachments/assets/9cc917f5-ecaf-42d2-8675-acbbdeadd71c)
* Catchzinho para tratamento de erros.

E, para fechar com chave dde ouro, usando o m√©todo listen para atribuir a nossa constante server a porta na qual nosso servidor ser√° exposto.
![image](https://github.com/user-attachments/assets/addc3cf5-eb0e-4af9-af4a-dbacd8c032e0)

Em termos de compara√ß√£o, o c√≥digo deste servidor foi quase tr√™s vezes maior que o do servidor bun. 

![image](https://github.com/user-attachments/assets/db2459db-868c-4202-8f2c-122d27dea98c)
* 123 linhas de c√≥digo.

Se me perguntassem hoje se eu preferia codar com bun ou com node, eu escolheria o bun. Foi, de fato, uma experi√™ncia bem divertida desenvolver com ele. Desde  etapa de inicializa√ß√£o at√© a de desenvolvimento, percebi que o bun √© superior ao node em diversas coisas. Mas eu gosto bastante do Node, n√£o se engane!!!
